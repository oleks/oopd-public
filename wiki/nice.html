<!DOCTYPE html><html><head><link href='http://fonts.googleapis.com/css?family=Ubuntu+Mono|Bitter:400,700,400italic' rel='stylesheet' type='text/css'><link rel='stylesheet' href='style.css'><meta charset='utf-8'></head><body><article><h1><a class='margin' name='S.0'>&sect; 0.&nbsp;</a>Imperative programming</h1><p>Consider doing the laundry. If we have a common, house-hold washing machine at our disposal &mdash; the <em>procedure</em>, may look something like this:</p><ol><li><p>split the laundry into whites and colours;</p></li><li><p>wash whites;</p></li><li><p>wash colours;</p></li><li><p>dry the laundry;</p></li><li><p>neatly stack up the laundry.</p></li></ol><p>In a conventional functional programming language, such as SML, this may end up looking like this:</p><a class='margin' name='L.0.0' href='#L.0.0'>Listing 0.0</a><code class='listing'><ol><li><pre>(stack (dry (wash (split laundry))))</pre></li></ol></code><p>While comprehensible, this does not read very well. Most languages we&#8217;re used to, i.e. <a target='_blank' href='http://en.wikipedia.org/wiki/Indo-european'>Indo-European languages</a>, read left-to-right, top-to-bottom. Here, the flow of the program is expressed right-to-left, and there is no notion of top-down descent at all. If anything, there&#8217;s a notion of bottom-up ascent, if we for instance, lay out the program like this:</p><a class='margin' name='L.0.1' href='#L.0.1'>Listing 0.1</a><code class='listing'><ol><li><pre>(stack</pre></li><li><pre>  (dry</pre></li><li><pre>    (wash</pre></li><li><pre>      (split laundry))))</pre></li></ol></code><p>This reads like we&#8217;re putting the cart before the horse. Indeed, some tasks &mdash; such as, doing the laundry, cooking a meal, writing a program, etc. &mdash; are inherently sequential, i.e. they are done by performing a sequence of steps. Functional programming languages can be <span class='tooltip' title='A programming language has syntactic rules defining the valid positioning of symbols. In this case, the syntactic rule is that the name precedes the arguments in a function call.'>syntactically</span> unfit for writing such programs well.</p><p>We will develop the notion of a <em>well-written program</em> throughout these lecture notes, but we begin with the following definition:</p><a class='margin' name='D.0.0' href='#D.0.0'>Definition 0.0</a><dfn><p>A well-written program is a well-read program.</p></dfn><p>That is, a well-written program is comprehensible to another programmer. Naturally, not any old programmer will do, but someone with relative knowledge of the problem domain, and programming experience comparable, or superceeding yours, should be able to comprehend and evaluate your programs. The intent is to facilitate a the review and evolution of your programs by your peers.</p><p>We were also somewhat <em>declarative</em> when we wrote the functional program. For instance, we&#8217;ve left out the fact that we should wash whites before we wash colours. Actually, we didn&#8217;t even mention that we split the laundry into whites and colours; we&#8217;ve left it up to the <var>wash</var> and <var>split</var> functions to discuss such &#8220;details&#8221;.</p><a class='margin' name='D.0.1' href='#D.0.1'>Definition 0.1</a><dfn><p>A declarative style of programming is a style where we tell the reader &#8220;what&#8221; we&#8217;re doing, rather than &#8220;how&#8221; we&#8217;re doing it.</p></dfn><p>An alternative functional program could be:</p><a class='margin' name='L.0.2' href='#L.0.2'>Listing 0.2</a><code class='listing'><ol><li><pre>let</pre></li><li><pre>  (dirtyWhites, dirtyColours) = split dirtyLaundry</pre></li><li><pre>  cleanWetWhites = wash dirtyWhites</pre></li><li><pre>  cleanWetColours = wash dirtyColours</pre></li><li><pre>  cleanLaundry = dry (cleanWetWhites, cleanWetColours)</pre></li><li><pre>in</pre></li><li><pre>  stack cleanLaundry</pre></li></ol></code><p>We&#8217;ll refer to lines 1&ndash;7 as a &#8220;<tt>let</tt>-block&#8221;, lines 2&ndash;4 as a &#8220;<tt>let</tt>-definitions&#8221;, and line 7 as a &#8220;<tt>let</tt>-expression&#8221;.</p><p>In functional programming, the <tt>let</tt>-syntax can be used to reduce the complexity of an expression by giving intuitive names to some of its constituents. This lets the reader read a simpler expression, and delve into the details, if necessary. As long as important details are retained in the <tt>let</tt>-expression, this is a useful technique for making your programs more readable.</p><p>However, in this particular case, the expression reduces to <code>stack cleanLaundry</code>. This seems overly declarative. We&#8217;re completely disregarding the important aspects of &#8220;doing the laundry&#8221;. We&#8217;re so eager not to tell the reader &#8220;how&#8221; we&#8217;re doing it, that we forget to tell the reader &#8220;what&#8221; we&#8217;re doing.</p><p>The <tt>let</tt>-syntax does however provide for a nice segway into another <span class='tooltip' title='A way of writing a particular class of programms well.'>programming paradigm</span>, more suitable for writing <em>procedures</em> like this. In particular, the <tt>let</tt>-syntax provides more than a simple mechanism for naming subexpressions. Notice, how we could use the name <var>dirtyWhites</var> when we defined <var>cleanWetWhites</var>, or how we could use <var>cleanWetWhites</var> when we defined <var>cleanLaundry</var>.</p><p>It is as if some sort of &#8220;state&#8221; evolves from one defintion to the next, in the sense that a name defined further up can be used in definitions further down. If we represent this &#8220;state&#8221; as the set of names available in the context of an expression, we can specify how the state develops throughout the <tt>let</tt>-block: </p><a class='margin' name='L.0.3' href='#L.0.3'>Listing 0.3</a><code class='listing'><ol><li><pre>let</pre></li><li><pre>  {dirtyLaundry}</pre></li><li><pre>  {dirtyLaundry, dirtyWhites, dirtyColours}</pre></li><li><pre>  {dirtyLaundry, dirtyWhites, dirtyColours,</pre></li><li><pre>    cleanWetWhites}</pre></li><li><pre>  {dirtyLaundry, dirtyWhites, dirtyColours,</pre></li><li><pre>    cleanWetWhites, cleanWetColours}</pre></li><li><pre>in</pre></li><li><pre>  {dirtyLaundry, dirtyWhites, dirtyColours,</pre></li><li><pre>    cleanWetWhites, cleanWetColours, cleanLaundry}</pre></li></ol></code><p>It seems overly excessive to have the state at the <tt>let</tt>-expression (lines 9&ndash;10) contain all these &#8220;intermediate&#8221; names, such as <var>dirtyWhites</var>, <var>cleanWetColours</var>, etc. All we really want in the <tt>let</tt>-expression is the <var>cleanLaundry</var>. What&#8217;s more, it does not conceptually make sense to be able to use the dirty, or wet laundry once the laundry has been washed and dried, right? Indeed, we&#8217;d like for the state develop in a fashion similar to this:</p><a class='margin' name='L.0.4' href='#L.0.4'>Listing 0.4</a><code class='listing'><ol><li><pre>{dirtyLaundry}</pre></li><li><pre>{dirtyWhites, dirtyColours}</pre></li><li><pre>{cleanWetWhites, cleanWetColours}</pre></li><li><pre>{cleanDryLaundry}</pre></li></ol></code><p>While we could attempt to attain this using nested <tt>let</tt>-blocks or <span class='tooltip' title='Functions whos sole purpose is to make other functions easier to comprehend.'>auxiliary functions</span>, the code will not be as easy as 1-2-3, i.e. as simple as our initial specification of the procedure.</p><p>The thing that is getting in the way here is that in the functional paradigm we&#8217;re dealing with <em>immutable</em> values. That is, values that can be created and destroyed, but not modified. Indeed, if the pile of laundry was a <em>mutable</em> value, we could simply step-wise modify that value from a dirty pile to a clean stack. After-all, this resembles what we do with the laundry in real life.</p><p>Let us thus focus in on a single statement:</p><a class='margin' name='L.0.5' href='#L.0.5'>Listing 0.5</a><code class='listing'><ol><li><pre>dirtyWhites, dirtyColours = split dirtyLaundry</pre></li></ol></code><p>If we let <var>dirtyLaundry</var> initially be a basket of mixed dirty laundry, we&#8217;de like for the <em>effect</em> of this statement to be that <var>dirtyWhites</var> becomes a pile of dirty whites, and <var>dirtyColours</var> becomes a pile of dirty colours, while <var>dirtyLaundry</var> becomes an <em>empty</em> basket. That is, we&#8217;d like for the laundry to be <em>moved</em> from the basket to their respective (recently created) piles.</p><p>At this point, it no longer makes sense to represent &#8220;state&#8221; as the mere set of names available in the context of an expression. It now also matters which <em>concrete values</em> these names actually refer to. Indeed, before the above statement, <var>dirtyLaundry</var> is a basket of dirty clothes; after it, it is an empty basket.</p><a class='margin' name='D.0.2' href='#D.0.2'>Definition 0.2</a><dfn><p>A mutable value, also known as a variable, is a named entity that can refer to different concrete values throughout the lifetime of a program.</p></dfn><p>If we represent baskets and piles as good old lists, we&#8217;d like for the state to evolve from</p><a class='margin' name='L.0.6' href='#L.0.6'>Listing 0.6</a><code class='listing'><ol><li><pre>{ dirtyLaundry = [A,B,C,D,...] }</pre></li></ol></code><p>to</p><a class='margin' name='L.0.7' href='#L.0.7'>Listing 0.7</a><code class='listing'><ol><li><pre>{ dirtyLaundry = [],</pre></li><li><pre>  dirtyWhites = [A,C,...], dirtyColours = [B,D,...] }</pre></li></ol></code><p>Let us hence consider the <var>split</var> procedure. </p><p><b>Assignment</b></p><p>ASCII report.</p><p>The DIKU canteen is the only completely student-driven canteen on the Copenhagen University campus. The canteen was established in 1971, and runs till this day. As a student-driven canteen, even the accounting is done by students. No biggie for Datalogy students, eh? We&#8217;ll see.</p><p>It is possible to buy from the canteen in bulk. The usual order consists of perhaps 30 bottles of soft drinks, and 30 bottles of beer. Although all soft drinks have the same price, beer prices may vary depending on how enthusiastic you are about beer. Indeed, DIKU alumni and research groups can be quite a picky bunch when it comes to beer specialities. We can without loss of generality constrain ourselves to beer.</p><p>Every time a bulk purchase is made, the items and quantities purchased are noted in a journal, leaving it to accounting to handle later.</p><p>This is where you come in. We need to write a program that can process the journal and produce a summary report in ASCII. The summary report should process the entire journal and provide as output:</p><ul><li><p>the total number of times each type of beer was purchased;</p></li><li><p>the total revenue made from each type of beer;</p></li><li><p>the overall revenue from bulk purchases;</p></li><li><p>an overview of the development of the revenue over time.</p></li></ul><pre>Guld Tuborg 10
Gr√∏n Tuborg 8
Leffe Brun 15
Leffe Blond 15</pre><p>The users will sometimes however chose to buy abnormal quantities of various drinks.</p><p>- Canteen accounting. List of items with their prices, followed by event  receipts.</p><p>- ASCII bar chart.</p><p>- Challenge of the week: ASCII line chart. Hint: don&#8217;t drink and derive!</p><p>Tracing the attacker&#8217;s IP.</p><p>- GUI in visual basic, LOL.</p><p>- Parse (csv-based) log files.</p><p>- Find comon behaviour:</p><p>- - Periodic access to the same resource.</p><p>- - Frequent access to different resources. </p></article><footer><address><h2>Datalogisk institut</h2><h1>University of Copenhagen</h1></address></footer></body></html>