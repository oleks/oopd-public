\chapter{Imperative programming}

Consider doing the laundry. If we have a common, house-hold washing machine at
our disposal --- the \emph{procedure}, may look something like this:

\begin{enumerate}

\item split the laundry into whites and colours;

\item wash whites;

\item wash colours;

\item dry the laundry;

\item neatly stack up the laundry.

\end{enumerate}

In a conventional functional programming language, such as SML, this may end up
looking like this:

\begin{code}
(stack (dry (wash (split laundry))))
\end{code}

While comprehensible, this does not read very well. Most languages we're used
to, i.e. \wikipedia{Indo-european}{Indo-European} languages, read
left-to-right, top-to-bottom. Here, the flow of the program is expressed
right-to-left, and there is no notion of top-down descent at all. If anything,
there's a notion of bottom-up ascent, if we for instance, lay out the program
like this:

\begin{code}
(stack
  (dry
    (wash
      (split laundry))))
\end{code}

This reads like we're putting the cart before the horse. Indeed, some tasks ---
such as, doing the laundry, cooking a meal, writing a program, etc. --- are
inherently sequential. Functional programming languages can be
\explain{syntactically}{A programming language has syntactic rules defining the
valid positioning of symbols. In this case, the syntactic rule is that the name
precedes the arguments in a function call.} unfit for writing such programs
well.

We will develop the notion of a \emph{well-written program} throughout these
lecture notes, but we begin with the following definition:

\begin{definition}

A well-written program is a well-read program.

\end{definition}

That is, a well-written program is comprehensible to another programmer.
Naturally, not any old programmer will do, but someone with relative knowledge
of the problem domain, and programming experience comparable, or superceeding
yours, should be able to comprehend and evaluate your programs. The intent is
to facilitate a the review and evolution of your programs by your peers.

We were also somewhat \emph{declarative} when we wrote the functional program.
For instance, we've left out the fact that we should wash whites before we wash
colours. Actually, we didn't even mention that we split the laundry into whites
and colours; we've left it up to the \var{wash} and \var{split} function
definitions to discuss such ``details''.

\begin{definition}

A declarative style of programming is a style where we tell the reader ``what''
we're doing, rather than ``how'' we're doing it.

\end{definition}

An alternative functional program for this procedure could be:

\begin{code}
let
  (dirtyWhites, dirtyColours) = split dirtyLaundry
  cleanWetWhites = wash dirtyWhites
  cleanWetColours = wash dirtyColours
  cleanLaundry = dry (cleanWetWhites, cleanWetColours)
in
  stack cleanLaundry
\end{code}

In functional programming, the \code{let}-syntax is used to reduce the
complexity of an expression by letting you give its subexpression intuitive
names. This allows the reader to read the expression, and delve into the
details of its constituents only if the reader wishes to do so. As long as
important deails are retained, this is a useful technique for making your
programs more readable.

In this particular case, the expression reduces to \code{stack
cleanLaundry}. This seems overly declarative. We're completely disregarding the
important aspects of ``doing the laundry''. We're so eager not to tell the
reader ``how'' we're doing it, that we forget to tell the reader ``what'' we're
doing.

The \code{let}-syntax does however provide for a nice segway into another
\explain{programming paradigm}{A way of writing a particular class of programms
well.}, more suitable for writing out \emph{procedures}. In particular, the
\code{let}-syntax provides more than a simple mechanism for naming
subexpressions. Note, how we could use the name \var{dirtyWhites} when we
defined \var{cleanWetWhites}, or how we could use \var{cleanWetWhites} when we
defined \var{cleanLaundry}.

It is as if some sort of ``state'' is retained from one defintion to the next,
such that names defined further up can be used in definitions further down. If
we represent ``state'' as the set of names available for use in an expression
we can specify how the state develops throughout the \code{let}-block: 

\begin{code}
let
  {dirtyLaundry}
  {dirtyLaundry, dirtyWhites, dirtyColours}
  {dirtyLaundry, dirtyWhites, dirtyColours,
    cleanWetWhites}
  {dirtyLaundry, dirtyWhites, dirtyColours,
    cleanWetWhites, cleanWetColours}
in
  {dirtyLaundry, dirtyWhites, dirtyColours,
    cleanWetWhites, cleanWetColours, cleanLaundry}
\end{code}

It seems overly excessive to have the state at the final expression contain
\emph{all} the ``intermediate'' names, such as \var{dirtyWhites},
\var{cleanWetColours}, etc. Indeed, all it really needs is the
\var{cleanLaundry}. This can be mitigated for using, say, a nested
\code{let}-block:

\begin{code}
let
  cleanLaundry =
    let
      (dirtyWhites, dirtyColours) = split dirtyLaundry
      cleanWetWhites = wash dirtyWhites
      cleanWetColours = wash dirtyColours
    in
      dry (cleanWetWhites, cleanWetColours)
in
  stack cleanLaundry
\end{code}

Which leads to the following evolution of the state:

\begin{code}
let
  let
    {dirtyLaundry}
    {dirtyLaundry, dirtyWhites, dirtyColours}
    {dirtyLaundry, dirtyWhites, dirtyColours,
      cleanWetWhites}
  in
    {dirtyWhites, dirtyColours, cleanWetWhites,
      cleanWetColours}
in
  {dirtyLaundry, cleanLaundry}
\end{code}

We may apply the same logic to the other intermediaries, such as washing
colours, and end up with perhaps a completely intollerable indentation level,
and something strikingly similar to our original program, except much more
verbose.

Alternatively, we may use \explain{auxiliary}{Functions whos sole purpose is to
make other functions easier to comprehend.} functions. For instance:

\begin{code}
washAndDry dirtyLandry =
  let
    (dirtyWhites, dirtyColours) = split dirtyLaundry
    cleanWetWhites = wash dirtyWhites
    cleanWetColours = wash dirtyColours
  in
    dry (cleanWetWhites, cleanWetColours)

doTheLaundry dirtyLaundry =
  let
    cleanLaundry = washAndDry dirtyLaundry
  in
    stack cleanLaundry
\end{code}

However, if we again consider applying this logic to other intermediaries, we
may end up with a dozen helper functions, which isn't too readable either.

Another question worth considering wrt. the final \code{let}-expression having
names like \var{dirtyLaundry} and \var{cleanWetWhites} at its disposal, is
whether it makes sense for us to be able to use them in the expression. If
we've really washed and dried all the laundry, hopefully there is no more dirty
or wet laundry, otherwise all our programming so far has been in vain.




{\bf Assignment}

ASCII report.

The DIKU canteen is the only completely student-driven canteen on the
Copenhagen University campus. The canteen was established in 1971, and runs
till this day. As a student-driven canteen, even the accounting is done by
students. No biggie for Datalogy students, eh? We'll see.

It is possible to buy from the canteen in bulk. The usual order consists of
perhaps 30 bottles of soft drinks, and 30 bottles of beer. Although all soft
drinks have the same price, beer prices may vary depending on how enthusiastic
you are about beer. Indeed, DIKU alumni and research groups can be quite a
picky bunch when it comes to beer specialities. We can without loss of
generality constrain ourselves to beer.

Every time a bulk purchase is made, the items and quantities purchased are
noted in a journal, leaving it to accounting to handle later.

This is where you come in. We need to write a program that can process the
journal and produce a summary report in ASCII. The summary report should
process the entire journal and provide as output:

\begin{itemize}

\item the total number of times each type of beer was purchased;

\item the total revenue made from each type of beer;

\item the overall revenue from bulk purchases;

\item an overview of the development of the revenue over time.

\end{itemize}

\begin{verbatim}
Guld Tuborg 10
Gr√∏n Tuborg 8
Leffe Brun 15
Leffe Blond 15
\end{verbatim}

The users will
sometimes however chose to buy abnormal quantities of various drinks.

- Canteen accounting. List of items with their prices, followed by event
  receipts.

- ASCII bar chart.

- Challenge of the week: ASCII line chart. Hint: don't drink and derive!

Tracing the attacker's IP.

- GUI in visual basic, LOL.

- Parse (csv-based) log files.

- Find comon behaviour:

- - Periodic access to the same resource.

- - Frequent access to different resources.
